# Ejercicio de SQLite: *app* de tareas pendientes

En este ejercicio vamos a crear una pequeña aplicación de gestión de tareas pendientes, en la que se puedan listar tareas y añadir tareas nuevas. Cada tarea tiene un `id` (entero, autonumérico), un `titulo` (cadena), una `prioridad` (entero) y un `vencimiento` (fecha). Las columnas están por este orden en la tabla.

## Configurar el proyecto

- Crear un proyecto llamado `TareasSQLite` de tipo *Master-Detail Application*
- En la carpeta `archivos SQLite` de las plantillas hay unos cuantos recursos que debes copiar al proyecto
	- **Copia en el proyecto la base de datos** `tareas.db` . Usa el menú `File > Add files to TareasSQLite...` y selecciona el archivo `tareas.db`. En el cuadro de diálogo de copia, pulsa sobre el boton `options` de la parte inferior y *asegúrate de que la casilla de `Copy files if needed` está marcada*.
	- **Copia en el proyecto el `DBManager.h` y el `DBManager.m`**, es muy parecido al que tienes en los apuntes.
- Añade la librería `libsqlite3.tbd` según se explica en los apuntes.

Para comprobar que funciona, introduce el siguiente código en el  método `application:didFinishLaunchingWithOptions:` del `AppDelegate.m`  (por ejemplo justo antes del `return YES`)

'' DBManager *dbm = [[DBManager alloc] initWithDB:@"tareas" reload:NO];

Si todo es correcto, en el *log* debe aparecer el mensaje “BD abierta”. Una vez que sepas que funciona puedes quitar esta línea para que no interfiera con el resto del ejercicio.

Nótese que como primer parámetro se pasa el nombre de la BD (sin la extensión `.db`), y como segundo un booleano indicando si la copia de la BD de `Documents` se va a sobreescribir cada vez que se arranque la aplicación (útil cuando en desarrollo estamos cambiando “desde fuera” la BD para hacer pruebas)


## Infraestructura básica (0,1 puntos)

 - Crea una clase de tipo “Cocoa Touch Class” llamada `Tarea` y añádele como propiedades:
	- `id` de tipo `NSInteger`
	-  `titulo` de tipo `NSString`
	- `prioridad` de tipo `NSInteger`
	- `vencimiento` de tipo `NSDate`

 > Recuerda que las propiedades se añaden en el archivo .h y la sintaxis es como sigue	

'' @property NSInteger id;
'' @property NSString *titulo
'' ...

- Crea una clase de tipo “Cocoa Touch Class” llamada `TareasManager` que sea una subclase de `DBManager`. En los siguientes apartados implementaremos aquí las operaciones con la tabla de tareas.

## Funcionalidad 1: Listar tareas (0,6 puntos)

### Implementar el listado en sí

En el `TareasManager.m` 

- Incluye un `#import "Tarea.h"`
- **Implementa un método `- (NSMutableArray *) listarTareas`** que debe devolver un array de objetos `Tarea` ordenados por fecha de vencimiento. *Será muy similar al código que sirve para listar alumnos en los apuntes*.

> Ten en cuenta que las fechas de `tareas.db` están almacenadas al estilo “tiempo UNIX”: número de segundos transcurridos desde el 1/1/1970

### Mostrar las tareas en la interfaz

Para probar que el código funciona vamos a introducir código en el `MasterViewController.m`

Pon los `#import` necesarios (de `TareasManager.h` y de `Tarea.h`)

Añade la siguiente propiedad en la sección de `@interface`, para almacenar una referencia al `TareasManager` 


'' @property TareasManager* tm;


En el `viewDidLoad` coloca el siguiente código, para probar el listado de tareas. Fijate que *la propiedad `objects` ya está definida* en la plantilla de Xcode, y que es un `NSMutableArray` de objetos a mostrar en pantalla (nosotros haremos que sean tareas)

''  self.tm = [[TareasManager alloc] initWithDB:@"tareas" reload:NO];
''  self.objects = [self.tm listarTareas];
''  //Hacemos que salgan en la consola
''  for (Tarea *t in self.objects) {
''      NSLog(@"%@", t.titulo);
''  }


Verás que *además aparecen las tareas en el interfaz gráfico* (ya que la plantilla de Xcode automáticamente rellena la tabla con los datos del array `objects`), pero no aparecen bien, se ve su dirección de memoria. Vamos a arreglar esto.
 
### Mostrar las tareas en la tabla

Para que las tareas aparezcan correctamente el interfaz  gráfico puedes cambiar la línea en el método `cellForRowAtIndexPath` que dice

''  cell.textLabel.text = [object description];


por otra que ponga en la etiqueta de texto la propiedad `titulo` de la tarea

'' cell.textLabel.text = [object valueForKey:@"titulo"];


Para poder ver algún detalle más en la lista, por ejemplo la fecha de vencimiento, abrir el *storyboard* y seleccionar la celda de tabla que aparece en la segunda pantalla de la aplicación. En las propiedades, cambiar el `Style` de `Basic` a `Subtitle`, por ejemplo (también valdrían los otros dos estilos)

En el código de `cellForRowAtIndexPath` incluir

'' NSDate *vencimiento = [object valueForKey:@"vencimiento"];
'' cell.detailTextLabel.text = [NSDateFormatter 
''      localizedStringFromDate:vencimiento 
''      dateStyle:NSDateFormatterMediumStyle 
''      timeStyle:NSDateFormatterNoStyle];


## Funcionalidad 2: Insertar nueva tarea (0,3 puntos)

### Implementar la “lógica” para esta funcionalidad

Implementar un método `- (BOOL) insertarTarea: (Tarea*) tarea` en la clase `TareasManager`, que inserte una nueva tarea en la BD y devuelva `YES` si todo ha ido bien y `NO` en caso contrario.

> Al campo `id` no es necesario darle valor al insertar un registro ya que es autonumérico.

Para comprobar que funciona correctamente, en el `viewDidLoad` del `MasterViewController.m` puedes colocar código que cree una tarea (hazlo antes del que las lista, para que la nueva esté incluida también en la lista de tareas)

'' Tarea *nueva = [[Tarea alloc] init];
'' nueva.titulo = @"Tarea nueva";
'' nueva.prioridad = 1;
'' //24*60*60 segundos posterior a la fecha actual -> mañana a la misma hora
'' nueva.vencimiento = [NSDate dateWithTimeIntervalSinceNow:24*60*60];
'' [self.tm insertarTarea:nueva];


> Incorporar la funcionalidad de nueva tarea al interfaz sería interesante pero excesivo, ya que el objetivo del ejercicio es el trabajo con SQLite, no con la GUI de iOS.