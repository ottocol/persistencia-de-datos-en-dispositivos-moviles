## Serialización de clases 

Lo que Apple denomina *archiving* o *encoding* es lo que en otros lenguajes normalmente se conoce como **serialización** o *marshalling*, es decir, transformar un objeto de cualquier clase o un grafo de objetos en una secuencia de bytes que se pueda almacenar en un archivo.

### Los protocolos `Encodable` y `Decodable` 

Para que un objeto sea serializable (o "archivable") debe implementar estos protocolos. `Encodable` se encarga de transformar de objeto a secuencia de bytes y `Decodable` a la inversa.

El protocolo `Encodable` declara un único método `encode`:

```swift
func encode(to: Encoder) throws
```

En la mayoría de casos no será necesario escribir nosotros mismos el código de este método, ya que lo generará automáticamente el compilador siempre que nuestra clase esté compuesta por campos que sean `Encodable`s. Muchos tipos básicos de Swift son `Encodable`, como los `String`, `Int`, `Float`, `Date`, `Array`...

Por otro lado, `Decodable`, que es el protocolo encargado de transformar de secuencia de bytes a objeto, declara un único inicializador:

```swift
init(from decoder: Decoder) throws
```

Al igual que con `Encodable`, si los campos que componen una clase son campos `Decodable`, nuestra clase lo será automáticamente y no tendremos que escribir el código del inicializador.

Existe un tercer protocolo, `Codable`, que no es más que una combinación de ambos, `Encodable` y `Decodable`:

```swift
typealias Codable = Encodable & Decodable
```

Los objetos que queramos que sean serializables y deserializables los declararemos como conformes a `Codable`.

Como ejemplo, supongamos que tenemos una clase `Alumno` que representa un alumno de un determinado curso o asignatura. Su definición podría ser algo como:

```swift
class Alumno  {
    var nombre : String?
    var varon : Bool = false
    var fechaNacimiento: Date?
    
    init(nombre elNombre: String, esVaron varon : Bool,
         nacido fechaNac: Date) {
        self.nombre = elNombre
        self.varon = varon
        self.fechaNacimiento = fechaNac
    }
}
```

Para que esta clase sea *serializable/deserializable* simplemente declaramos que es conforme al protocolo `Codable` :

```swift
class Alumno : Codable {
```


### Archivar y “desarchivar” objetos

Hasta ahora hemos visto los *hooks* a definir en nuestro código cuando "alguien" ejecute el proceso de archivado/desarchivado. Para ejecutar el archivado tenemos el método estático `archiveRootObject` de la clase `NSKeyedArchiver`. 

```swift
//Creamos las estructuras de datos en memoria
let a = Alumno(nombre: "Eva", esVaron: false, nacido:Date())
let a2 = Alumno(nombre: "Pepe", esVaron: true, nacido:Date())
let grupo = Grupo(nombre: "primero A", miembros: [a,a2])

//Como es un ejemplo simple, obtenemos el dir. temporal y allí creamos un archivo
let tmpDir = FileManager.default.temporaryDirectory
let archivoGrupo = tmpDir.appendingPathComponent("grupo.dat")

//Archivamos el objeto. Como segundo parámetro necesitamos un path, no una URL
NSKeyedArchiver.archiveRootObject(grupo, toFile: archivoGrupo.path)
```

Para el paso contrario, de "reconstituir" un grafo de objetos a partir de un archivo, usamos el método `unarchiveObject` de `NSKeyedUnarchiver`:

```swift
if let grupoLeido = NSKeyedUnarchiver.unarchiveObject(withFile: archivoGrupo.path) as? Grupo {
    for alumno in grupoLeido.miembros {
        print(alumno.nombre!)
    }
}
```
