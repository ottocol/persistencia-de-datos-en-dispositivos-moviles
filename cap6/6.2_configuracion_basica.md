
## Un "fetched results controller" básico

Vamos a empezar con un *fetched results controller* "mínimo". Supondremos que estamos usando un *view controller* que hereda de `UITableViewController` (aunque no va a haber gran diferencia si no usamos esta clase).

Lo primero es crear el `NSFetchedResultsController`. Para ello necesitamos como mínimo dos cosas:

- Asociarle una *fetch request*, que devuelva los datos que queramos mostrar en la tabla.
- Que dicha *request* esté ordenada. Ya hemos visto que Core Data no asegura por defecto un orden determinado al obtener los resultados de una *fetch request*, pero las filas de la tabla sí tienen un orden definido, por lo que necesitamos que los resultados también lo tengan.

Además podemos crear una *cache* para que sea más eficiente. Como veremos es muy sencillo y no requiere casi trabajo por nuestra parte. 

Continuaremos con el ejemplo de los usuarios, las conversaciones y los mensajes. Vamos a hacer por ejemplo una tabla que muestre los mensajes (entidad y clase `Mensaje`). Para simplificar el código, gestionaremos el `NSFetchedResultsController` en el *controller* de la pantalla con la tabla. Lo primero es definirnos una propiedad para almacenarlo, ya que lo usaremos en diversos métodos:

```swift
import UIKit
import CoreData

class MiController : UITableViewController {
  var frc : NSFetchedResultsController<Mensaje>! 

  ...
}
```

Ahora podemos inicializar el *fetched results controller* en el `viewDidLoad`

```swift
override func viewDidLoad() {
    super.viewDidLoad()

    let miDelegate = UIApplication.shared.delegate! as! AppDelegate
    let miContexto = miDelegate.persistentContainer.viewContext
    
    let consulta = NSFetchRequest<Mensaje>(entityName: "Mensaje")
    
    let sortDescriptors = [NSSortDescriptor(key:"fecha", ascending:false)]
    consulta.sortDescriptors = sortDescriptors
    self.frc = NSFetchedResultsController<Mensaje>(fetchRequest: consulta, managedObjectContext: miContexto, sectionNameKeyPath: nil, cacheName: "miCache")

    //continuará
    ...
}
```

Esto inicializa el *fetched results controller* pero todavía no ejecuta la *query*. Para comprobar que funciona podemos imprimir provisionalmente los datos en la consola:

```swift
//Esto vendría también dentro del viewDidLoad, a continuación de lo anterior
//Ejecutamos el fetch
try! self.frc.performFetch()
//"fetchedObjects" contiene los resultados
if let resultados = frc.fetchedObjects {
    print("Hay \(resultados.count) mensajes")
    for mensaje in resultados {
        print (mensaje.texto!)
    }
}
```

Como puede verse, para ejecutar la *query* hay que llamar a `performFetch()`. Los resultados estarán accesibles en forma de array en `fetchedObjects`. No obstante esta no es la forma típica de obtener los resultados, para eso hubiéramos ejecutado el *fetch* directamente. Vamos a "comunicar" el *fetched results controller* con la tabla para que sea ella la que le pida los datos conforme los vaya necesitando. 

Recordemos que las tablas toman los datos de su *datasource*, un objeto que debe implementar una serie de métodos usados para devolver el contenido: devolver el número de secciones, devolver el número de filas y devolver una fila en concreto.



Recordemos que las tablas tienen un *datasource* que es el objeto que implementa los métodos necesarios para “suministrar” el contenido a la vista: `numberOfSectionsInTableView`, `tableView:numberOfRowsInSection:` y `tableView:cellForRowAtIndexPath:`. En el caso que nos ocupa, el *datasource* es el *controller* de la pantalla con la tabla, y ahí es donde estarán estos métodos. Normalmente la fuente de los datos es un array de objetos, pero ahora va a ser el  ```NSFetchedResultsController``. El código quedará como sigue.

Para devolver el número de secciones de la tabla, podemos usar la propiedad `sections` del *fetched results controller*. En realidad por el momento podríamos devolver simplemente `1`, ya que hemos dicho que no tenemos secciones en la tabla, pero vamos a dejar el código preparado para no tener que modificarlo luego.

    - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
        return [[self.frController sections] count];
    }

Recordemos que `frController` es una propiedad que hemos definido y referencia al dichoso *fetched results controller*.

El método que devuelve el número de filas en la sección actual es ligeramente más complicado, pero siempre es igual, así que podemos usar un copia/pega literal:

    - (NSInteger)tableView:(UITableView *)tableView 
                 numberOfRowsInSection:(NSInteger)section {
        id<NSFetchedResultsSectionInfo> sectionInfo = 
                                   [self.frController sections][section];
        return [sectionInfo numberOfObjects];
    }

en ``sectionInfo```accedemos a la sección número `section` del *controller*. Como vemos, las secciones son objetos que implementan el protocolo `NSFetchedResultsSectionInfo`. La propiedad `numberOfObjects` nos devuelve el número de componentes de la sección.

Finalmente nos falta el método que devuelve una celda:

    - (UITableViewCell *)tableView:(UITableView *)tableView 
                         cellForRowAtIndexPath:(NSIndexPath *)indexPath {
        //Recuerda cambiar el "cell" por tu reuse identifier
        UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell" 
                                           forIndexPath:indexPath];
        NSManagedObject *nota = [self.frController objectAtIndexPath:indexPath];
        cell.textLabel.text = [nota valueForKey:@"texto"];
        return cell;
    }

La única diferencia con la versión anterior es que en lugar de obtener la nota de un `NSArray`, la obtenemos del  *fetched results controller*. 

> Una alternativa a crear el *fetched results controller* manualmente, como se hace aquí, es usar la plantilla de Xcode de “Master/Detail” marcando “Use Core Data”. Generará automáticamente uno para la pantalla con la vista maestra, con todo el código configurado.

Con todo esto ya tenemos la misma funcionalidad que teníamos antes, a partir de ahora vamos a ver qué ventajas adicionales nos da el nuevo *controller* frente a la versión anterior.

## Refrescar la tabla

Seguimos teniendo el mismo problema de la primera versión: cada vez que creamos una nueva nota esta no aparece en la tabla. Pero ahora podemos resolverlo de forma más sencilla con el *fetched results controller*, ya que este está “suscrito” a los cambios que se producen en el contexto de persistencia (siempre que afecten a los contenidos en su *fetch request*. 

Para que el *fetched results controller* nos avise a su vez de estos cambios, tenemos que convertirnos en su *delegate*. Tenemos que “decirle” que lo somos a través de su propiedad `delegate`

    //En el viewDidLoad, tras crear el fetched results controller
    self.frController.delegate = self;

> Lo anterior, en lugar de por código, se puede hacer gráficamente en Xcode con el *connections inspector*

Por tanto tendremos que pasar a implementar el protocolo correspondiente, ya que el *fetched results controller* llamará a una serie de métodos cuando se modifique el contexto

    //ListaNotasController.h
    #import <UIKit/UIKit.h>
    //Esta línea es IMPORTante :)
    #import <CoreData/CoreData.h>
    
    @interface ListaNotasController : UITableViewController <NSFetchedResultsControllerDelegate>
    ...
    @end

Por ejemplo, cuando se ha modificado algún objeto del contexto se llamará a `controllerDidChangeContent`. Podemos aprovechar este método para refrescar los datos de la tabla:

    - (void) controllerDidChangeContent:(NSFetchedResultsController *)controller {
        [self.tableView reloadData];
    }

Ahora ya se mostrarán los datos de las nuevas notas creadas, y también estarán actualizados si se modificaran o borraran. Una ventaja de esta nueva versión es que si no ha cambiado ningún objeto no perderemos tiempo recargando los datos al mostrar la pantalla. Si en la versión de la primera sesión hubiéramos puesto el código en el `viewWillAppear` hubiera funcionado igual pero a costa de recargar siempre.

Si ahora implementamos el método `tableView:commitEditingStyle:forRowAtIndexPath:` podremos reaccionar también al gesto de *swipe to delete* (si el usuario pasa el dedo por la celda de derecha a izquierda). Dentro de este método podríamos borrar del contexto el objeto correspondiente a la fila, algo como

    - (void)tableView:(UITableView *)tableView 
              commitEditingStyle:(UITableViewCellEditingStyle)editingStyle 
              forRowAtIndexPath:(NSIndexPath *)indexPath {
        if (editingStyle == UITableViewCellEditingStyleDelete) {
            //Borramos el objeto gestionado
            [[self.frController managedObjectContext]
                deleteObject:[self.frController objectAtIndexPath:indexPath]];
            NSError *error;
            [[self.frController managedObjectContext] save:&error];
            if (error) {
                NSLog(@"Error al intentar borrar objeto");
            }
        }
    } 

La tabla se actualizaría automáticamente ya que al cambiar (desaparecer) un objeto, se dispararía el `controllerDidChangeContent`. Eso sí, no quedaría muy bonito desde el punto de vista de la interfaz ya que no habría ningún tipo de animación.

## Editar la tabla


En una aplicación en la que podamos insertar, actualizar y eliminar datos teniendo visible la tabla es mucho más intuitivo para el usuario ver cómo aparecen, desaparecen y se modifican las filas con una animación, como es habitual en las aplicaciones de iOS.

Siendo el *delegate* del *fetched results controller* podemos saber que un objeto del contexto ha cambiado y qué cambio se ha producido implementando el método `controller:didChangeObject:atIndexPath:forChangeType:newIndexPath:`. El nombre es “un poco” largo, pero como siempre los parámetros son bastante autoexplicativos. Quién es el *fetched results controller*, qué objeto ha cambiado, en qué fila estaba, qué cambio se ha producido (inserción, la cte.`NSFetchedResultsChangeInsert`, borrado, la cte. `NSFetchedResultsChangeDelete`,…) y en qué fila va a acabar el objeto (para inserciones o movimientos). Aprovecharemos este método para actualizar visualmente las filas que toquen, por ejemplo:

    - (void)controller:(NSFetchedResultsController *)controller 
                   didChangeObject:(id) anObject
                   atIndexPath:(NSIndexPath *) indexPath 
                   forChangeType:(NSFetchedResultsChangeType) type
                   newIndexPath:(NSIndexPath *) newIndexPath {
        UITableView *tableView = self.tableView;
        switch(type) {
            case NSFetchedResultsChangeInsert:
                [tableView insertRowsAtIndexPaths:@[newIndexPath] 
                           withRowAnimation:UITableViewRowAnimationFade];
                break;
        ...
    
     }
    

> Como hemos dicho, una forma sencilla de ver un ejemplo completo de código es examinar la plantilla de una nueva aplicación de tipo “Master/Detail” con Core Data.

Cuando se usa esta forma de trabajar, podemos conseguir que si se modifican varios objetos simultáneamente se haga una única animación. Para agrupar animaciones se usan los métodos de `UITableView` llamados `beginUpdates` y `endUpdates`. Así haríamos:

    - (void)controllerWillChangeContent:(NSFetchedResultsController *)controller { 
      [self.tableView beginUpdates];
    }
    - (void)controllerDidChangeContent:(NSFetchedResultsController *)controller { 
      [self.tableView endUpdates];
    }

De modo que cuando el *fetched results controller* nos informa que va a haber cambios, a su vez informamos a la tabla de ello, y lo mismo cuando acaban los cambios.

## Secciones automáticas

Podemos conseguir generar secciones de modo automático basándonos en alguna propiedad de la entidad sobre la que se hace la *fetch request*. Tiene que ser la misma propiedad que se usa para ordenar o alguna basada en ella, ya que elementos que siguen el orden del listado no pueden ir alternando de sección (las secciones no se repiten).

Al crear el *fetched results controller* especificamos  en el parámetro `sectionNameKeyPath` la propiedad a usar para generar secciones:

    [[NSFetchedResultsController alloc] initWithFetchRequest:request 
     managedObjectContext:miContexto sectionNameKeyPath:@"DiaFecha" 
     cacheName:@"miCache"];

En este caso suponemos que `DiaFecha` sería solamente el día de creación de la nota, sin hora. Se podría implementar como una propiedad *transient* y calculada  a partir de la propiedad *fecha*. Evidentemente para esto tendríamos que crear una clase `Nota` propia, y no usar directamente `NSManagedObject *`

En el *datasource* de la tabla tenemos también que implementar el método que genera los títulos de las secciones. El *fetched results controller* los generará por nosotros, de modo que este código siempre va a ser igual en todas las aplicaciones:

    - (NSString *) tableView:(UITableView *)tableView titleForHeaderInSection:
                     (NSInteger)section {
        id <NSFetchedResultsSectionInfo> sectionInfo = 
                              [[self.frController sections] objectAtIndex:section];
        return [sectionInfo name];
    }

