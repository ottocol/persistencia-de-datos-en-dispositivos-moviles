### Recuperar datos (0,4 puntos)

Vamos a añadir una pantalla donde se puedan consultar las notas que tenemos almacenadas. Las listaremos en una *table view* y por el momento se verán todas, no se podrá filtrar (añadiremos esa posibilidad cuando veamos la sintaxis de las "consultas" o *fetch requests*).

#### La interfaz de usuario

Sigue estos pasos:

- **Crear el Tab Bar Controller**: teniendo seleccionada la única pantalla de la aplicación, ve al menú y selecciona `Editor > Embed In > Tab Bar Controller`. Se creará el *tab bar controller*, por el momento con una única "solapa" que será la pantalla de creación de notas
- En la pantalla de creación de notas, pulsa sobre el item de la barra inferior para editarlo, y ponle como `Title` por ejemplo `Nueva`, para que se vea que es la pantalla de creación de notas
- Crear la pantalla para listar notas: Arrastrar al *storyboard* un `Table view controller`. Recuerda que es una especie de tabla a “pantalla completa”. 
- Vamos a configurar la interfaz de la nueva pantalla
	- Cambia el título del item de la barra inferior para que ponga "Lista" o algo similar.
	- Cambia el aspecto del prototipo de la tabla: pulsa sobre la celda prototipo de la tabla, y en las propiedades cambia el `Style` a `Right Detail` (así mostraremos tanto parte del contenido como la fecha)  
	- Pon un *reuse identifier*: pon algún `Identifier` por ejemplo `MiCelda` (recuerda que este identificador se emplea luego en el código para solicitar al sistema instancias reutilizables de celdas)
- Ahora vamos a configurar el controlador de la pantalla
	- Primero tenemos que crear un controlador (`File>New>File...`). De las plantillas que aparecen usa `Cocoa Touch Class`, así Xcode generará código por nosotros. La clase  se debe llamar `ListaNotasController` y heredará de `UITableViewController`. 

![](img/crear_listanotascontroller.png)

	- Ahora hacer que la nueva clase sea el controlador de la pantalla de listado de notas: tienes que seleccionar la pantalla de listado de notas (primero de los iconos de la barra superior, el de fondo amarillo) y en el Identity Inspector (tercero de los iconos del área de la derecha), como "Custom Class" poner `ListaNotasController`
- Ya solo queda vincular la nueva pantalla al *tab bar controller*: hacer `Ctrl+Arrastrar` desde la pantalla del *tab bar* hasta la de listado de notas. En el menú contextual elegir como tipo del *segue* el de, `View Controllers` (bajo `Relationship Segue`).

Puedes probar a ejecutar el proyecto para ver que funciona el cambio de pantallas. Evidentemente la lista de notas aparecerá vacía. Al menos, poniendo un `print` con algún mensaje en el `viewDidLoad` del `ListaNotasController` puedes comprobar que efectivamente se usa esta clase como controlador de la nueva pantalla. Cuando la muestras por primera vez debería aparecer el mensaje.

#### El código de la pantalla de listado

En la tabla vamos a dibujar un *array* de notas. Lo primero será definir una propiedad para almacenarlas en la clase `ListaNotasController`

```swift
//RECUERDA que hace falta este import
import CoreData

class ListaNotasController: UITableViewController {
   var notas : [NSManagedObject]?

}
```

Fíjate que la definimos como un array de `NSManagedObject` es decir, de objetos gestionados por Core Data.

Solo nos queda rellenar el array de notas. Para recuperar datos de Core Data se usa un *fetch request*, que sería algo así como una consulta. para crearlo, inicializamos una instancia pasándole el nombre de la entidad resultado de la consulta. Para ejecutarlo, llamamos al método `fetch` del contexto. Algo como:

```swift
let request : NSFetchRequest<NSFetchRequestResult> = NSFetchRequest(entityName:"Nota")
//"miContexto" es el contexto de Core Data 
if let notas = try? miContexto.fetch(request) as! [NSManagedObject] {
   for nota in notas {
       print(nota.value(forKey: "fecha")!)
   }
}
```

Nótese que los *fetch request* usan tipos. Es decir, un *fetch request* es un *fetch request* que devuelve alguna clase determinada. Como por el momento no tenemos una clase `Nota`, usamos el tipo genérico `NSFetchRequestResult`

En el `viewDidLoad` de `ListaNotasController` puedes introducir el siguiente código


	AppDelegate *miDelegate = [[UIApplication sharedApplication] delegate];
	NSManagedObjectContext *miContexto = [miDelegate managedObjectContext];
	NSFetchRequest *fetchRequest = [NSFetchRequest 
	          fetchRequestWithEntityName:@"Nota"];
	NSError *error;
	self.notas = [miContexto executeFetchRequest:fetchRequest
	                            error:&error];
	//refrescar la tabla, si no no aparecerán los datos
	[self.tableView reloadData];

Fíjate en que *las nuevas notas que creemos no van a aparecer en la lista*, salvo que pares la aplicación y la vuelvas a arrancar, ya que el `viewDidLoad` solo se ejecuta una vez. Habría dos soluciones posibles: una sería colocar el código en el método `viewWillAppear`, que se ejecuta justo antes de mostrar un controlador (habrá que añadirlo manualmente, ya que la plantilla de Xcode no lo sobreescribe por defecto). Otra sería usar un *fetched results controller* para mostrar los datos, que es lo que se usa normalmente cuando se quieren mostrar datos de Core Data en una tabla. Este *controller* es mucho más flexible y potente y gestiona automáticamente cosas como la actualización automática del listado si se actualizan los objetos persistentes. Veremos los *fetched results controllers* en sesiones posteriores.


Tendrás también que modificar los métodos de gestión de la tabla. En la plantilla ya están definidos, pero aparecen entre comentarios, descoméntalos y modifícalos como sigue:

- `numberOfSectionsInTableView`, para que devuelva 1, ya que solo hay una sección en la tabla
- `tableView:numberOfRowsInSection:`, para que devuelva el tamaño del array `notas`.
- `tableView:cellForRowAtIndexPath:`, para que devuelva la celda en la fila especificada.

Este último quedaría:

	UITableViewCell *cell = [tableView
	          dequeueReusableCellWithIdentifier:@"Cell" 
	          forIndexPath:indexPath];   
	// Configure the cell...
	cell.textLabel.text = [self.notas[indexPath.row] 
	                        valueForKey:@"texto"];



